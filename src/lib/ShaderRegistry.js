/**
 * Auto-generated shader registry
 * Generated by: scripts/build-shaders.js
 * Do not edit manually!
 */

// Base vertex shader (shared by all card effects)
export const BASE_VERTEX = `#version 300 es
precision highp float;

layout(location = 0) in vec3 a_position;
layout(location = 1) in vec2 a_uv;
layout(location = 2) in vec3 a_normal;
layout(location = 3) in vec3 a_tangent;

uniform mat4 u_modelMatrix;
uniform mat4 u_viewMatrix;
uniform mat4 u_projectionMatrix;
uniform vec3 u_cameraPosition;

out vec2 v_uv;
out vec3 v_worldPosition;
out vec3 v_worldNormal;
out vec3 v_viewDirection;
out vec3 v_tangentViewDir;
out float v_depth;

void main() {
    // World position
    vec4 worldPos = u_modelMatrix * vec4(a_position, 1.0);
    v_worldPosition = worldPos.xyz;

    // View and clip position
    vec4 viewPos = u_viewMatrix * worldPos;
    gl_Position = u_projectionMatrix * viewPos;

    // Depth (normalized for effects, near=0.1, far=10.0)
    v_depth = clamp((-viewPos.z - 0.1) / (10.0 - 0.1), 0.0, 1.0);

    // World normal (rotation only, no scale applied to normals)
    mat3 normalMatrix = mat3(u_modelMatrix);
    v_worldNormal = normalize(normalMatrix * a_normal);

    // View direction (from surface to camera)
    v_viewDirection = normalize(u_cameraPosition - v_worldPosition);

    // Tangent space view direction (for parallax/normal mapping)
    vec3 T = normalize(normalMatrix * a_tangent);
    vec3 N = v_worldNormal;
    vec3 B = cross(N, T);
    mat3 TBN = transpose(mat3(T, B, N));
    v_tangentViewDir = TBN * v_viewDirection;

    // UV passthrough
    v_uv = a_uv;
}
`

// Card effect shaders
export const CARD_SHADERS = {
    'base': {
        vertex: BASE_VERTEX,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;

out vec4 fragColor;

void main() {
    vec4 baseColor = texture(u_baseTexture, v_uv);
    vec3 finalColor = baseColor.rgb;

    // Overlay text on base texture (white text)
    float textAlpha = texture(u_textTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), textAlpha);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        fragColor = vec4(vec3(maskValue), baseColor.a);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = 1 for card pixels (no bloom for base shader, handled by bloom threshold)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'holographic': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_maskActive;
uniform float u_textOpacity;

out vec4 fragColor;

// Effect parameters
const float FRESNEL_POWER = 2.5;
const float CHROMATIC_ABERRATION = 0.008;

// Multi-layer rainbow parameters
const float RAINBOW_INTENSITY_1 = 0.5;   // Large scale rainbow
const float RAINBOW_INTENSITY_2 = 0.3;   // Medium scale rainbow
const float RAINBOW_INTENSITY_3 = 0.2;   // Fine scale rainbow

// Sparkle parameters
const float SPARKLE_DENSITY = 80.0;
const float SPARKLE_THRESHOLD = 0.92;
const float SPARKLE_INTENSITY = 1.5;

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

vec3 chromaticAberration(sampler2D tex, vec2 uv, float amount) {
    vec2 center = vec2(0.5);
    vec2 dir = uv - center;
    float dist = length(dir);
    vec2 offset = normalize(dir + 0.0001) * dist * amount;

    float r = texture(tex, uv + offset).r;
    float g = texture(tex, uv).g;
    float b = texture(tex, uv - offset).b;

    return vec3(r, g, b);
}

// Hash function for sparkle generation
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

// Generate rainbow phase for a given scale and offset
float getRainbowPhase(vec2 uv, vec2 tilt, float lightAngle, float fresnel, float scale, float offset) {
    float phase = lightAngle * 1.0;
    phase += (uv.x * tilt.y + uv.y * tilt.x) * scale * 0.5;
    phase += fresnel * 0.15;
    phase += offset;
    return fract(phase);
}

void main() {
    float tiltMagnitude = length(u_cardRotation);
    // 0% minimum when no mask, 30% minimum when mask is active
    float minEffect = u_maskActive > 0.5 ? 0.3 : 0.0;
    float effectIntensity = minEffect + tiltMagnitude * (1.0 - minEffect);

    // Store original base color for mask blending
    vec4 originalBase = texture(u_baseTexture, v_uv);
    vec3 originalColor = originalBase.rgb;
    float alpha = originalBase.a;

    // Base color with chromatic aberration based on tilt
    float chromaAmount = CHROMATIC_ABERRATION * tiltMagnitude * 3.0;
    vec3 baseColor = chromaticAberration(u_baseTexture, v_uv, chromaAmount);

    // Sample noise texture for organic variation
    vec3 noise = texture(u_noiseTexture, v_uv * 3.0).rgb;
    float noiseValue = noise.r;

    // Calculate fresnel for edge effects
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);

    // Calculate light reflection angle
    vec3 lightDir = normalize(vec3(0.0, 0.5, 1.0));
    vec3 reflectDir = reflect(-lightDir, v_worldNormal);
    float lightAngle = max(dot(reflectDir, v_viewDirection), 0.0);

    // === MULTI-LAYER RAINBOW ===
    // Layer 1: Large scale rainbow bands
    float phase1 = getRainbowPhase(v_uv, u_cardRotation, lightAngle, fresnel, 3.0, 0.0);
    vec3 rainbow1 = texture(u_rainbowGradient, vec2(phase1, 0.5)).rgb;

    // Layer 2: Medium scale with noise distortion
    float phase2 = getRainbowPhase(v_uv, u_cardRotation, lightAngle, fresnel, 6.0, noiseValue * 0.5);
    vec3 rainbow2 = texture(u_rainbowGradient, vec2(phase2, 0.5)).rgb;

    // Layer 3: Fine scale, more responsive to tilt
    float phase3 = getRainbowPhase(v_uv, u_cardRotation * 1.5, lightAngle, fresnel, 12.0, 0.33);
    vec3 rainbow3 = texture(u_rainbowGradient, vec2(phase3, 0.5)).rgb;

    // Combine rainbow layers
    float effectStrength = smoothstep(0.0, 0.25, effectIntensity);
    effectStrength *= (0.4 + lightAngle * 0.6);

    vec3 rainbowCombined = vec3(0.0);
    rainbowCombined += rainbow1 * RAINBOW_INTENSITY_1;
    rainbowCombined += rainbow2 * RAINBOW_INTENSITY_2;
    rainbowCombined += rainbow3 * RAINBOW_INTENSITY_3;
    rainbowCombined *= effectStrength;

    // === MICRO-SPARKLE ===
    vec2 sparkleUV = v_uv * SPARKLE_DENSITY;
    vec2 sparkleCell = floor(sparkleUV);
    vec2 sparkleFract = fract(sparkleUV);

    float sparkle = 0.0;
    // Check neighboring cells for sparkles
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 cell = sparkleCell + vec2(float(x), float(y));
            float h = hash(cell);

            if (h > SPARKLE_THRESHOLD) {
                // Random position within cell
                vec2 sparklePos = vec2(hash(cell + 1.0), hash(cell + 2.0));
                float dist = length(sparkleFract - sparklePos - vec2(float(x), float(y)));

                // Sparkle visibility based on effect intensity (deterministic)
                float visibility = smoothstep(0.05, 0.3, effectIntensity);

                // Sharp sparkle falloff
                float sparkleSize = 0.08 * (0.5 + h * 0.5);
                float sparkleBright = smoothstep(sparkleSize, sparkleSize * 0.2, dist);
                sparkleBright *= visibility * SPARKLE_INTENSITY * (0.5 + h * 0.5);

                sparkle += sparkleBright;
            }
        }
    }

    // Sparkle color (white with slight rainbow tint)
    vec3 sparkleColor = mix(vec3(1.0), rainbow1, 0.3) * sparkle;

    // === TEXTURE OVERLAY ===
    // Add subtle noise texture variation to break up smooth gradients
    float textureOverlay = (noiseValue - 0.5) * 0.15 * effectStrength;

    // === HIGHLIGHT BAND ===
    float highlightPos = u_cardRotation.y * 0.5 + 0.5;
    float highlight = 1.0 - abs(v_uv.x - highlightPos) * 2.0;
    highlight = smoothstep(0.0, 1.0, highlight) * (lightAngle * lightAngle) * 0.25;

    // === RIM LIGHTING ===
    vec3 rimColor = vec3(0.6, 0.8, 1.0);
    vec3 rim = rimColor * pow(fresnel, 2.5) * 0.4 * effectIntensity;

    // === COMBINE ALL EFFECTS ===
    vec3 holoEffect = rainbowCombined;
    holoEffect += sparkleColor;
    holoEffect += vec3(highlight);
    holoEffect += vec3(textureOverlay);

    vec3 finalColor = baseColor + holoEffect + rim;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask (including text)
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'foil': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_foilPattern;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Effect parameters
const float SPECULAR_POWER = 64.0;
const float SPARKLE_INTENSITY = 1.2;
const float SPARKLE_THRESHOLD = 0.85;

float calculateSpecular(vec3 normal, vec3 viewDir, vec3 lightDir) {
    vec3 halfVec = normalize(lightDir + viewDir);
    float spec = max(dot(normal, halfVec), 0.0);
    return pow(spec, SPECULAR_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);

    // Light direction influenced by card tilt (simulates environment reflection)
    vec3 lightDir = normalize(vec3(
        u_cardRotation.y * 2.0 + 0.3,
        -u_cardRotation.x * 2.0 + 0.5,
        1.0
    ));

    // Main specular highlight
    float spec = calculateSpecular(v_worldNormal, v_viewDirection, lightDir);

    // Sparkle pattern - visibility depends on light angle, not time
    vec2 sparkleUV = v_uv * 40.0;
    float sparkleNoise = texture(u_foilPattern, sparkleUV).r;

    // Sparkles appear based on how the light hits each micro-facet
    float sparkleAngle = spec * 0.5 + 0.5;
    float sparkleThreshold = SPARKLE_THRESHOLD - effectIntensity * 0.1;
    float sparkle = 0.0;
    if (sparkleNoise > sparkleThreshold) {
        // Sparkle intensity based on angle alignment
        sparkle = (sparkleNoise - sparkleThreshold) * SPARKLE_INTENSITY;
        sparkle *= sparkleAngle;
    }

    // Main vertical streak (follows tilt)
    float bandPos = u_cardRotation.y * 0.6 + 0.5;
    float band = max(0.0, 1.0 - abs(v_uv.x - bandPos) * 3.0);
    band = band * band * band * spec * 0.65;

    // Bottom-left vertical streak (simple linear falloff)
    float bottomBandX = u_cardRotation.y * 0.5 + 0.25;
    float bottomStreak = max(0.0, 1.0 - abs(v_uv.x - bottomBandX) * 6.0);
    bottomStreak *= max(0.0, v_uv.y - 0.5) * 2.0;  // Fade in at bottom half
    bottomStreak = bottomStreak * bottomStreak * effectIntensity * 0.6;

    // Circular brushed metal effect (anisotropic highlight)
    vec2 fromCenter = v_uv - 0.5;
    float dist = length(fromCenter);
    float angle = atan(fromCenter.y, fromCenter.x);
    float circularAngle = angle + u_cardRotation.y * 3.0 - u_cardRotation.x * 2.0;
    float circular = sin(circularAngle * 8.0) * 0.5 + 0.5;
    // Brighter core that fades toward edges
    float coreBrightness = 1.0 - dist * 1.2;
    coreBrightness = max(0.2, coreBrightness);
    // Base visibility + spec boost (visible even when spec is low)
    circular = circular * circular * (0.35 + spec * 0.6) * effectIntensity * coreBrightness;

    // Fresnel for edge glint
    float fresnel = 1.0 - max(dot(v_worldNormal, v_viewDirection), 0.0);
    fresnel = fresnel * fresnel * fresnel;

    // Metallic tint
    vec3 metalColor = vec3(1.0, 0.95, 0.88);
    vec3 highlightColor = vec3(1.0, 1.0, 1.0);

    // Combine effects
    vec3 foilEffect = metalColor * spec * 0.85;  // Main specular
    foilEffect += highlightColor * (sparkle + band + bottomStreak);
    foilEffect += metalColor * circular;  // Brushed metal circles
    foilEffect += metalColor * fresnel * 0.15 * effectIntensity;

    // Final color
    vec3 finalColor = baseColor + foilEffect;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'parallax': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_depthMap;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Hash functions for procedural generation
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// Generate a star field layer
float starLayer(vec2 uv, float density, float seed, float starSize) {
    float stars = 0.0;

    // Grid-based star placement
    vec2 gridUV = uv * density;
    vec2 cellId = floor(gridUV);
    vec2 cellUV = fract(gridUV);

    // Check current cell and neighbors for stars
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 neighbor = vec2(float(x), float(y));
            vec2 id = cellId + neighbor;

            // Random position within cell
            float h = hash(id + seed);
            float h2 = hash2(id + seed * 2.0);

            // More stars (lower threshold)
            if (h > 0.55) {
                vec2 starPos = neighbor + vec2(hash(id + seed + 1.0), hash(id + seed + 2.0)) * 0.8 + 0.1;
                float dist = length(cellUV - starPos);

                // Star brightness with smooth falloff
                float size = starSize * (0.6 + h2 * 0.4);
                float brightness = smoothstep(size, size * 0.05, dist);

                // Add twinkle variation based on position
                brightness *= 0.8 + 0.2 * h2;

                stars += brightness;
            }
        }
    }

    return stars;
}

// Star layer parameters - 7 layers
const int NUM_LAYERS = 7;

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    // Get base card texture (no parallax on this)
    vec4 baseColor = texture(u_baseTexture, v_uv);
    vec3 originalColor = baseColor.rgb;  // Store for mask blending

    // Tilt vector for parallax
    vec2 tilt = u_cardRotation;
    float tiltMagnitude = length(tilt);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);

    // Star layer configuration - 7 layers
    // Parallax range: -0.40 to +0.20
    float parallaxStrengths[7];
    parallaxStrengths[0] = -0.40;  // Far back
    parallaxStrengths[1] = -0.30;
    parallaxStrengths[2] = -0.20;
    parallaxStrengths[3] = -0.10;
    parallaxStrengths[4] =  0.00;  // Middle (stationary)
    parallaxStrengths[5] =  0.10;
    parallaxStrengths[6] =  0.20;  // Front

    // Density: back layers sparser, middle denser
    float densities[7];
    densities[0] = 10.0;
    densities[1] = 14.0;
    densities[2] = 18.0;
    densities[3] = 22.0;
    densities[4] = 25.0;
    densities[5] = 22.0;
    densities[6] = 18.0;

    // Sizes: back small, front large
    float sizes[7];
    sizes[0] = 0.05;
    sizes[1] = 0.06;
    sizes[2] = 0.07;
    sizes[3] = 0.08;
    sizes[4] = 0.09;
    sizes[5] = 0.10;
    sizes[6] = 0.12;

    // Brightness range: 0.5 to 1.25
    float brightnesses[7];
    brightnesses[0] = 0.50;
    brightnesses[1] = 0.625;
    brightnesses[2] = 0.75;
    brightnesses[3] = 0.875;
    brightnesses[4] = 1.0;
    brightnesses[5] = 1.125;
    brightnesses[6] = 1.25;

    // Color tints (back=blue, front=warm)
    vec3 colors[7];
    colors[0] = vec3(0.4, 0.5, 1.0);   // Deep blue (far back)
    colors[1] = vec3(0.5, 0.6, 1.0);
    colors[2] = vec3(0.6, 0.7, 1.0);
    colors[3] = vec3(0.75, 0.8, 1.0);
    colors[4] = vec3(0.9, 0.9, 1.0);   // White (middle)
    colors[5] = vec3(1.0, 0.95, 0.9);
    colors[6] = vec3(1.0, 0.9, 0.8);   // Warm (front)

    // Accumulate stars from all layers
    vec3 starColor = vec3(0.0);

    for (int i = 0; i < NUM_LAYERS; i++) {
        // Apply parallax offset to UV
        // Swap axes: tilt.y (horizontal mouse) -> uv.x, tilt.x (vertical mouse) -> uv.y
        vec2 offsetUV = v_uv + vec2(tilt.y, tilt.x) * parallaxStrengths[i];

        // Generate stars for this layer
        float stars = starLayer(offsetUV, densities[i], float(i) * 100.0, sizes[i]);

        // Add colored stars
        starColor += stars * brightnesses[i] * colors[i];
    }

    // Fresnel rim effect for depth
    float fresnel = 1.0 - max(dot(v_worldNormal, v_viewDirection), 0.0);
    fresnel = pow(fresnel, 2.5);
    vec3 rimGlow = vec3(0.3, 0.4, 0.8) * fresnel * 0.5 * effectIntensity;

    // Combine: base texture + stars + rim
    vec3 finalColor = baseColor.rgb;
    finalColor += starColor;
    finalColor += rimGlow;

    // Slight vignette to frame the effect
    float vignette = 1.0 - length(v_uv - 0.5) * 0.25;
    finalColor *= vignette;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), baseColor.a);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'cracked-ice': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const float CELL_SCALE = 12.0;
const float CRACK_WIDTH = 0.04;
const float CRACK_GLOW = 1.0;
const float CELL_TINT_STRENGTH = 0.4;
const float FRESNEL_POWER = 2.5;

// Hash functions
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

vec2 hash2D(vec2 p) {
    return vec2(
        hash(p),
        hash(p + vec2(127.1, 311.7))
    );
}

// Voronoi distance field - returns distance to nearest cell edge
float voronoi(vec2 uv, float scale, out vec2 cellCenter, out float cellId) {
    vec2 scaledUV = uv * scale;
    vec2 cell = floor(scaledUV);
    vec2 frac = fract(scaledUV);

    float minDist = 1.0;
    vec2 nearestPoint = vec2(0.0);
    vec2 nearestCell = vec2(0.0);

    // Check 3x3 neighborhood
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 neighbor = vec2(float(x), float(y));
            vec2 currentCell = cell + neighbor;

            // Random point within this cell
            vec2 point = hash2D(currentCell) * 0.8 + 0.1;
            vec2 diff = neighbor + point - frac;
            float dist = length(diff);

            if (dist < minDist) {
                minDist = dist;
                nearestPoint = point;
                nearestCell = currentCell;
            }
        }
    }

    cellCenter = nearestPoint;
    cellId = hash(nearestCell);
    return minDist;
}

// Second pass to find edge distance
float voronoiEdge(vec2 uv, float scale) {
    vec2 scaledUV = uv * scale;
    vec2 cell = floor(scaledUV);
    vec2 frac = fract(scaledUV);

    float minDist1 = 1.0;
    float minDist2 = 1.0;

    // Find two nearest points
    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 neighbor = vec2(float(x), float(y));
            vec2 currentCell = cell + neighbor;
            vec2 point = hash2D(currentCell) * 0.8 + 0.1;
            vec2 diff = neighbor + point - frac;
            float dist = length(diff);

            if (dist < minDist1) {
                minDist2 = minDist1;
                minDist1 = dist;
            } else if (dist < minDist2) {
                minDist2 = dist;
            }
        }
    }

    // Edge is where two cells meet
    return minDist2 - minDist1;
}

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // Calculate voronoi
    vec2 cellCenter;
    float cellId;
    float dist = voronoi(v_uv, CELL_SCALE, cellCenter, cellId);
    float edgeDist = voronoiEdge(v_uv, CELL_SCALE);

    // Crack lines (edges between cells)
    float crack = 1.0 - smoothstep(0.0, CRACK_WIDTH, edgeDist);

    // Each cell gets a unique color tint based on tilt
    float cellPhase = fract(cellId + tilt.x * 0.5 + tilt.y * 0.5);
    vec3 cellTint = texture(u_rainbowGradient, vec2(cellPhase, 0.5)).rgb;

    // Cell brightness variation
    float cellBrightness = 0.85 + cellId * 0.3;

    // Apply cell tint based on effect intensity
    vec3 cellColor = mix(baseColor, baseColor * cellTint, CELL_TINT_STRENGTH * effectIntensity);
    cellColor *= cellBrightness;

    // Light direction based on tilt
    vec3 lightDir = normalize(vec3(tilt.y * 2.0, -tilt.x * 2.0 + 0.5, 1.0));

    // Specular highlight per cell (each cell reflects differently)
    vec3 cellNormal = normalize(vec3(
        (cellId - 0.5) * 0.3,
        (hash(vec2(cellId * 10.0, 0.0)) - 0.5) * 0.3,
        1.0
    ));
    vec3 reflectDir = reflect(-lightDir, cellNormal);
    float spec = pow(max(dot(reflectDir, v_viewDirection), 0.0), 32.0);
    spec *= effectIntensity;

    // Crack glow color (bright cyan/white)
    vec3 crackColor = vec3(0.7, 0.9, 1.0);

    // Crack glow intensity increases with effect
    float crackGlow = crack * CRACK_GLOW * (0.3 + effectIntensity * 0.7);

    // Fresnel for edge effect
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);
    vec3 rimColor = vec3(0.5, 0.7, 1.0);
    vec3 rim = rimColor * fresnel * 0.4 * effectIntensity;

    // Combine effects
    vec3 finalColor = cellColor;
    finalColor += vec3(spec * 0.4);
    finalColor += crackColor * crackGlow;
    finalColor += rim;

    // Slight darkening at crack edges for depth
    finalColor *= 1.0 - crack * 0.2;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'refractor': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const float NUM_LINES = 24.0;
const float LINE_SHARPNESS = 2.5;
const float RAINBOW_INTENSITY = 0.5;
const float HOTSPOT_SIZE = 12.0;
const float FRESNEL_POWER = 2.5;
const float PI = 3.14159265359;

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // Center point shifts slightly with tilt
    vec2 center = vec2(0.5) + tilt * 0.1;
    vec2 dir = v_uv - center;
    float angle = atan(dir.y, dir.x);
    float dist = length(dir);

    // Create radial lines that rotate with tilt
    float lineAngle = angle + tilt.y * 3.0 + tilt.x * 2.0;
    float lines = sin(lineAngle * NUM_LINES) * 0.5 + 0.5;
    lines = pow(lines, LINE_SHARPNESS);

    // Add secondary finer lines
    float fineLines = sin(lineAngle * NUM_LINES * 2.0 + PI * 0.5) * 0.5 + 0.5;
    fineLines = pow(fineLines, LINE_SHARPNESS * 1.5) * 0.3;
    lines = lines * 0.7 + fineLines;

    // Rainbow color based on angle (shifts with tilt)
    float rainbowPhase = fract(angle / (2.0 * PI) + tilt.x * 0.3 + tilt.y * 0.2);
    vec3 rainbow = texture(u_rainbowGradient, vec2(rainbowPhase, 0.5)).rgb;

    // Fade toward edges (stronger in center)
    float radialFade = 1.0 - smoothstep(0.2, 0.8, dist);

    // Central hotspot glow
    float hotspot = exp(-dist * dist * HOTSPOT_SIZE);
    hotspot *= effectIntensity * 1.5;

    // Combine line effect with rainbow
    float lineEffect = lines * radialFade;
    vec3 refractorColor = rainbow * lineEffect * RAINBOW_INTENSITY * effectIntensity;

    // Add bright center
    vec3 hotspotColor = vec3(1.0, 0.98, 0.95) * hotspot;

    // Secondary rainbow ring
    float ring = smoothstep(0.25, 0.3, dist) * smoothstep(0.45, 0.35, dist);
    vec3 ringColor = rainbow * ring * 0.3 * effectIntensity;

    // Fresnel rim
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);
    vec3 rimColor = vec3(0.6, 0.8, 1.0);
    vec3 rim = rimColor * fresnel * 0.35 * effectIntensity;

    // Light streaks (lens flare effect)
    float streak1 = pow(max(0.0, 1.0 - abs(dir.x) * 4.0), 4.0) * exp(-abs(dir.y) * 3.0);
    float streak2 = pow(max(0.0, 1.0 - abs(dir.y) * 4.0), 4.0) * exp(-abs(dir.x) * 3.0);
    float streaks = (streak1 + streak2) * effectIntensity * 0.3;

    // Combine all effects
    vec3 finalColor = baseColor;
    finalColor += refractorColor;
    finalColor += hotspotColor;
    finalColor += ringColor;
    finalColor += rim;
    finalColor += vec3(streaks);

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'galaxy': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const int STAR_LAYERS = 4;
const float STAR_BRIGHTNESS = 1.2;
const float FRESNEL_POWER = 2.5;

// Nebula parameters
const float NEBULA_INTENSITY = 0.5;
const float RAINBOW_BLEND = 0.35;
const float ANGLE_THRESHOLD = 0.12;

// Hash functions
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

float hash2(vec2 p) {
    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
}

// Procedural value noise (no texture sampling)
float valueNoise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    // Smooth interpolation
    vec2 u = f * f * (3.0 - 2.0 * f);

    // Four corners
    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    // Bilinear interpolation
    return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

// Fractal Brownian Motion using procedural noise
float fbm(vec2 p) {
    float value = 0.0;
    float amplitude = 0.5;

    for (int i = 0; i < 4; i++) {
        value += valueNoise(p) * amplitude;
        p *= 2.1;
        amplitude *= 0.5;
    }
    return value;
}

// Nebula shape using FBM (completely static - no tilt in position)
float nebulaNoise(vec2 uv, vec2 offset) {
    vec2 pos = uv * 3.0 + offset;
    float n = fbm(pos);
    return smoothstep(0.3, 0.7, n);
}

// Star layer generation
float starLayer(vec2 uv, float density, float seed, float starSize) {
    float stars = 0.0;
    vec2 gridUV = uv * density;
    vec2 cellId = floor(gridUV);
    vec2 cellUV = fract(gridUV);

    for (int x = -1; x <= 1; x++) {
        for (int y = -1; y <= 1; y++) {
            vec2 neighbor = vec2(float(x), float(y));
            vec2 cell = cellId + neighbor;
            float h = hash(cell + seed);
            float h2 = hash2(cell + seed * 2.0);

            if (h > 0.6) {
                vec2 starPos = neighbor + vec2(hash(cell + seed + 1.0), hash(cell + seed + 2.0)) * 0.8 + 0.1;
                float dist = length(cellUV - starPos);
                float size = starSize * (0.5 + h2 * 0.5);
                float brightness = smoothstep(size, size * 0.1, dist);
                brightness *= 0.7 + 0.3 * h2;
                stars += brightness;
            }
        }
    }
    return stars;
}

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // === NEBULA CLOUDS (STATIC POSITION - procedural, no texture) ===
    // Three nebula patches at fixed positions

    // Patch 1: upper left area
    float nebula1 = nebulaNoise(v_uv, vec2(0.15, 0.1));
    // Visible when tilting right (positive tilt.x)
    float vis1 = smoothstep(ANGLE_THRESHOLD, ANGLE_THRESHOLD + 0.15, tilt.x);
    vis1 *= smoothstep(0.5, 0.3, tilt.x);

    // Patch 2: lower right area
    float nebula2 = nebulaNoise(v_uv, vec2(-0.25, -0.15));
    // Visible when tilting left (negative tilt.x)
    float vis2 = smoothstep(-ANGLE_THRESHOLD, -ANGLE_THRESHOLD - 0.15, tilt.x);
    vis2 *= smoothstep(-0.5, -0.3, tilt.x);

    // Patch 3: center-bottom area
    float nebula3 = nebulaNoise(v_uv, vec2(0.0, -0.2));
    // Visible when tilting up/down (tilt.y)
    float vis3 = smoothstep(ANGLE_THRESHOLD, ANGLE_THRESHOLD + 0.15, abs(tilt.y));
    vis3 *= smoothstep(0.5, 0.3, abs(tilt.y));

    // === NEBULA COLORS ===
    vec3 nebulaColor1 = vec3(0.25, 0.08, 0.45);  // Purple
    vec3 nebulaColor2 = vec3(0.1, 0.18, 0.5);    // Blue
    vec3 nebulaColor3 = vec3(0.45, 0.12, 0.5);   // Magenta

    // Rainbow iridescence - phase based on UV position + tilt
    float rainbowPhase1 = fract(v_uv.x * 0.8 + v_uv.y * 0.5 + tilt.x * 0.5 + tilt.y * 0.3);
    float rainbowPhase2 = fract(v_uv.x * 0.6 - v_uv.y * 0.7 + tilt.x * 0.4 - tilt.y * 0.4);
    float rainbowPhase3 = fract(v_uv.y * 0.9 + tilt.y * 0.6);

    vec3 rainbow1 = texture(u_rainbowGradient, vec2(rainbowPhase1, 0.5)).rgb;
    vec3 rainbow2 = texture(u_rainbowGradient, vec2(rainbowPhase2, 0.5)).rgb;
    vec3 rainbow3 = texture(u_rainbowGradient, vec2(rainbowPhase3, 0.5)).rgb;

    // Blend base color with rainbow
    vec3 finalNebula1 = mix(nebulaColor1, rainbow1, RAINBOW_BLEND * vis1);
    vec3 finalNebula2 = mix(nebulaColor2, rainbow2, RAINBOW_BLEND * vis2);
    vec3 finalNebula3 = mix(nebulaColor3, rainbow3, RAINBOW_BLEND * vis3);

    // Combine all nebula patches
    vec3 totalNebula = vec3(0.0);
    totalNebula += finalNebula1 * nebula1 * vis1;
    totalNebula += finalNebula2 * nebula2 * vis2;
    totalNebula += finalNebula3 * nebula3 * vis3;

    // === STAR FIELD (multiple layers with parallax) ===
    vec3 starColor = vec3(0.0);

    float densities[4];
    densities[0] = 8.0;
    densities[1] = 15.0;
    densities[2] = 25.0;
    densities[3] = 40.0;

    float sizes[4];
    sizes[0] = 0.12;
    sizes[1] = 0.08;
    sizes[2] = 0.05;
    sizes[3] = 0.03;

    float parallax[4];
    parallax[0] = 0.15;
    parallax[1] = 0.08;
    parallax[2] = 0.03;
    parallax[3] = 0.0;

    vec3 starTints[4];
    starTints[0] = vec3(1.0, 0.9, 0.7);   // Warm (close)
    starTints[1] = vec3(1.0, 1.0, 1.0);   // White
    starTints[2] = vec3(0.8, 0.9, 1.0);   // Cool
    starTints[3] = vec3(0.6, 0.7, 1.0);   // Blue (far)

    for (int i = 0; i < STAR_LAYERS; i++) {
        vec2 offsetUV = v_uv + vec2(tilt.y, tilt.x) * parallax[i];
        float stars = starLayer(offsetUV, densities[i], float(i) * 100.0, sizes[i]);
        starColor += stars * STAR_BRIGHTNESS * starTints[i];
    }

    // === SHOOTING STAR (moves diagonally with up/down tilt) ===
    vec2 shootDir = normalize(vec2(0.7, -0.7));  // Diagonal: top-left to bottom-right
    // Start offset toward top-right, moves along diagonal based on tilt.y
    vec2 shootCenter = vec2(0.65, 0.35) + vec2(tilt.y, -tilt.y) * 0.4;
    float shootPos = dot(v_uv - shootCenter, shootDir);
    float shootWidth = abs(dot(v_uv - shootCenter, vec2(-shootDir.y, shootDir.x)));
    // Half length, 25% thinner
    float shootStar = smoothstep(-0.075, 0.0, shootPos) * smoothstep(0.175, 0.075, shootPos);
    shootStar *= smoothstep(0.011, 0.0, shootWidth);
    shootStar *= smoothstep(0.05, 0.15, abs(tilt.y));  // Only visible when tilting up/down

    // Fresnel rim
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);
    vec3 rimColor = vec3(0.4, 0.3, 0.8);
    vec3 rim = rimColor * fresnel * 0.5 * effectIntensity;

    // === COMBINE ===
    vec3 spaceBase = baseColor * 0.7;

    vec3 finalColor = spaceBase;
    finalColor += totalNebula * NEBULA_INTENSITY;
    finalColor += starColor;
    finalColor += vec3(shootStar) * vec3(1.0, 0.95, 0.8);
    finalColor += rim;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'starburst': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const float NUM_RAYS = 16.0;
const float RAY_SHARPNESS = 3.0;
const float RAY_FALLOFF = 1.8;
const float GLOW_SIZE = 10.0;
const float RAINBOW_TINT = 0.45;
const float FRESNEL_POWER = 2.5;
const float PI = 3.14159265359;

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // Center follows the mouse (reversed direction)
    vec2 center = vec2(0.5) - vec2(tilt.y, tilt.x) * 0.4;
    vec2 dir = v_uv - center;
    float angle = atan(dir.y, dir.x);
    float dist = length(dir);

    // === PRIMARY RAYS ===
    // Rays rotate more with tilt
    float rayAngle = angle + tilt.y * 4.0 - tilt.x * 3.0;
    float rays = sin(rayAngle * NUM_RAYS) * 0.5 + 0.5;
    rays = pow(rays, RAY_SHARPNESS);

    // Rays fade with distance
    float rayFade = exp(-dist * RAY_FALLOFF);
    rays *= rayFade;

    // Add noise variation for organic look
    float noise = texture(u_noiseTexture, v_uv * 4.0).r;
    rays *= 0.7 + noise * 0.5;

    // === SECONDARY RAYS (finer) ===
    float fineRays = sin(rayAngle * NUM_RAYS * 2.0 + PI * 0.25) * 0.5 + 0.5;
    fineRays = pow(fineRays, RAY_SHARPNESS * 1.5);
    fineRays *= rayFade * 0.4;

    // === CENTRAL GLOW ===
    float glow = exp(-dist * dist * GLOW_SIZE);

    // Glow intensity (brighter core)
    float glowIntensity = 0.35 + effectIntensity * 0.6;

    // === RAINBOW TINT on rays ===
    float rainbowPhase = fract(angle / (2.0 * PI) + 0.5);
    vec3 rainbow = texture(u_rainbowGradient, vec2(rainbowPhase, 0.5)).rgb;

    // === LENS FLARE ARTIFACTS ===
    // Horizontal and vertical streaks
    float hStreak = exp(-abs(dir.y) * 8.0) * exp(-abs(dir.x) * 2.0);
    float vStreak = exp(-abs(dir.x) * 8.0) * exp(-abs(dir.y) * 2.0);
    float streaks = (hStreak + vStreak) * 0.3;

    // Secondary glow ring
    float ring = smoothstep(0.15, 0.2, dist) * smoothstep(0.35, 0.25, dist);
    ring *= 0.4;

    // === COLORS ===
    vec3 rayColor = mix(vec3(1.0, 0.98, 0.9), rainbow, RAINBOW_TINT * effectIntensity);
    vec3 glowColor = vec3(1.0, 0.95, 0.85);
    vec3 streakColor = vec3(1.0, 0.9, 0.95);

    // Fresnel rim
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);
    vec3 rimColor = vec3(1.0, 0.8, 0.6);
    vec3 rim = rimColor * fresnel * 0.3 * effectIntensity;

    // === COMBINE ===
    float totalRays = rays + fineRays;
    vec3 burstEffect = rayColor * totalRays * effectIntensity * 0.6;
    burstEffect += glowColor * glow * glowIntensity;  // Brighter core
    burstEffect += streakColor * streaks * effectIntensity * 0.5;
    burstEffect += rainbow * ring * effectIntensity * 0.8;  // More color in ring

    vec3 finalColor = baseColor;
    finalColor += burstEffect;
    finalColor += rim;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'prizm': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const float GRID_SIZE = 10.0;
const float COLOR_INTENSITY = 0.55;
const float EDGE_WIDTH = 0.03;
const float FACET_VARIATION = 0.4;
const float SPECULAR_POWER = 24.0;
const float FRESNEL_POWER = 2.5;

// Hash function
float hash(vec2 p) {
    p = fract(p * vec2(234.34, 435.345));
    p += dot(p, p + 34.23);
    return fract(p.x * p.y);
}

float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return pow(fresnel, FRESNEL_POWER);
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // === TRIANGLE GRID ===
    vec2 scaled = v_uv * GRID_SIZE;
    vec2 cell = floor(scaled);
    vec2 local = fract(scaled);

    // Determine which triangle (upper-left or lower-right of cell)
    bool upperTriangle = local.x + local.y < 1.0;

    // Unique ID for each triangle
    float triangleId = hash(cell) + (upperTriangle ? 0.0 : 0.5);
    triangleId = fract(triangleId * 1.7);

    // === FACET COLOR ===
    // Each triangle gets a unique rainbow phase that shifts with tilt
    float phase = fract(triangleId + tilt.x * 1.5 + tilt.y * 1.5);
    vec3 prizmColor = texture(u_rainbowGradient, vec2(phase, 0.5)).rgb;

    // === FACET LIGHTING ===
    // Each triangle has a slightly perturbed normal
    vec3 facetNormal = normalize(vec3(
        (hash(cell + 0.1) - 0.5) * FACET_VARIATION,
        (hash(cell + 0.2) - 0.5) * FACET_VARIATION,
        1.0
    ));

    // Light direction based on tilt
    vec3 lightDir = normalize(vec3(tilt.y * 2.0, -tilt.x * 2.0 + 0.5, 1.0));

    // Diffuse lighting per facet
    float diffuse = max(dot(facetNormal, lightDir), 0.0);

    // Specular highlight per facet
    vec3 reflectDir = reflect(-lightDir, facetNormal);
    float spec = pow(max(dot(reflectDir, v_viewDirection), 0.0), SPECULAR_POWER);
    spec *= effectIntensity;

    // === EDGE DETECTION ===
    // Distance to nearest triangle edge
    float edge;
    if (upperTriangle) {
        // Upper triangle: edges at x=0, y=0, x+y=1
        edge = min(local.x, min(local.y, 1.0 - local.x - local.y));
    } else {
        // Lower triangle: edges at x=1, y=1, x+y=1
        edge = min(1.0 - local.x, min(1.0 - local.y, local.x + local.y - 1.0));
    }
    float edgeMask = smoothstep(0.0, EDGE_WIDTH, edge);

    // Edge glow
    float edgeGlow = (1.0 - edgeMask) * 0.5 * effectIntensity;

    // === COMBINE ===
    // Mix base color with prizm color based on effect
    vec3 facetColor = mix(baseColor, prizmColor, COLOR_INTENSITY * effectIntensity);

    // Apply lighting
    facetColor *= 0.6 + diffuse * 0.5;
    facetColor += vec3(spec * 0.5);

    // Darken edges slightly
    facetColor *= 0.85 + edgeMask * 0.15;

    // Add edge glow
    vec3 edgeColor = vec3(0.9, 0.95, 1.0);
    facetColor += edgeColor * edgeGlow;

    // Fresnel rim
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);
    vec3 rimColor = vec3(0.6, 0.8, 1.0);
    vec3 rim = rimColor * fresnel * 0.35 * effectIntensity;

    vec3 finalColor = facetColor + rim;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
    'etched': {
        vertex: null,
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;
in vec3 v_worldPosition;
in vec3 v_worldNormal;
in vec3 v_viewDirection;
in vec3 v_tangentViewDir;
in float v_depth;

uniform sampler2D u_baseTexture;
uniform sampler2D u_rainbowGradient;
uniform sampler2D u_noiseTexture;
uniform sampler2D u_depthMap;
uniform sampler2D u_effectMask;
uniform sampler2D u_textTexture;
uniform sampler2D u_numberTexture;
uniform sampler2D u_collectionTexture;
uniform float u_time;
uniform vec2 u_mousePosition;
uniform vec2 u_cardRotation;
uniform float u_showMask;
uniform float u_textOpacity;

out vec4 fragColor;

// Parameters
const float MATTE_FACTOR = 0.55;
const float METALLIC_SPEC_POWER = 64.0;
const float EMBOSS_STRENGTH = 0.7;
const float PATTERN_SCALE = 25.0;
float calculateFresnel(vec3 normal, vec3 viewDir) {
    float fresnel = 1.0 - max(dot(normal, viewDir), 0.0);
    return fresnel * fresnel;  // FRESNEL_POWER = 2.0
}

// Minimum effect visibility (30%)
const float MIN_EFFECT = 0.3;

void main() {
    vec4 baseTexture = texture(u_baseTexture, v_uv);
    vec3 baseColor = baseTexture.rgb;
    vec3 originalColor = baseColor;  // Store for mask blending
    float alpha = baseTexture.a;

    float tiltMagnitude = length(u_cardRotation);
    float effectIntensity = MIN_EFFECT + tiltMagnitude * (1.0 - MIN_EFFECT);
    vec2 tilt = u_cardRotation;

    // === ETCH MASK ===
    // Use depth map for etched areas (bright = metallic, dark = matte)
    float depthMask = texture(u_depthMap, v_uv).r;

    // Also add a procedural pattern (grid of dots/lines)
    float patternX = sin(v_uv.x * PATTERN_SCALE * 3.14159) * 0.5 + 0.5;
    float patternY = sin(v_uv.y * PATTERN_SCALE * 3.14159) * 0.5 + 0.5;
    float dots = patternX * patternY;
    dots = smoothstep(0.3, 0.7, dots);

    // Combine masks: depth map + pattern
    float etchMask = max(depthMask, dots * 0.5);
    etchMask = smoothstep(0.3, 0.7, etchMask);

    // === MATTE AREAS ===
    // Reduced brightness, no specular, grainy texture
    float noise = texture(u_noiseTexture, v_uv * 8.0).r;
    vec3 matteColor = baseColor * MATTE_FACTOR;
    matteColor *= 0.85 + noise * 0.2; // More visible texture variation
    // Desaturate matte areas slightly for more contrast
    float matteLuma = dot(matteColor, vec3(0.299, 0.587, 0.114));
    matteColor = mix(matteColor, vec3(matteLuma), 0.25);

    // === METALLIC AREAS ===
    // Light direction
    vec3 lightDir = normalize(vec3(
        tilt.y * 2.0 + 0.2,
        -tilt.x * 2.0 + 0.4,
        1.0
    ));

    // Specular highlight
    vec3 halfVec = normalize(lightDir + v_viewDirection);
    float spec = pow(max(dot(v_worldNormal, halfVec), 0.0), METALLIC_SPEC_POWER);

    // Metallic color (bright, with specular)
    vec3 metallicColor = baseColor * 1.4;
    metallicColor += vec3(spec * 1.2 * effectIntensity);

    // Strong color shift on metallic areas
    float colorShift = tilt.x * 0.2 + tilt.y * 0.2;
    metallicColor *= 1.0 + vec3(colorShift, colorShift * 0.5, -colorShift) * effectIntensity * 1.5;

    // === EMBOSS EFFECT ===
    // Sample neighboring pixels to create beveled edge look
    float texelSize = 1.0 / 512.0;
    float maskLeft = texture(u_depthMap, v_uv - vec2(texelSize, 0.0)).r;
    float maskRight = texture(u_depthMap, v_uv + vec2(texelSize, 0.0)).r;
    float maskUp = texture(u_depthMap, v_uv - vec2(0.0, texelSize)).r;
    float maskDown = texture(u_depthMap, v_uv + vec2(0.0, texelSize)).r;

    // Emboss gradient
    float embossX = (maskRight - maskLeft) * EMBOSS_STRENGTH;
    float embossY = (maskDown - maskUp) * EMBOSS_STRENGTH;

    // Light emboss based on tilt
    float embossLight = embossX * tilt.y + embossY * (-tilt.x);
    embossLight *= effectIntensity * 2.0;

    // === FRESNEL RIM ===
    float fresnel = calculateFresnel(v_worldNormal, v_viewDirection);

    // Metallic areas get more rim effect
    vec3 rimColor = vec3(0.8, 0.85, 1.0);
    vec3 rim = rimColor * fresnel * 0.7 * effectIntensity * etchMask;

    // === COMBINE ===
    vec3 finalColor = mix(matteColor, metallicColor, etchMask);

    // Add emboss lighting
    finalColor += vec3(embossLight * 0.5);

    // Add rim
    finalColor += rim;

    // Slight vignette
    float vignette = 1.0 - length(v_uv - 0.5) * 0.15;
    finalColor *= vignette;

    // Apply effect mask: blend between original and effect based on mask
    float mask = texture(u_effectMask, v_uv).r;
    // Add text to the mask (text areas get the effect)
    float textMask = texture(u_textTexture, v_uv).r;
    mask = max(mask, textMask);
    finalColor = mix(originalColor, finalColor, mask);

    // Add white overlay for text readability (opacity controlled by uniform)
    finalColor = mix(finalColor, vec3(1.0), textMask * u_textOpacity);

    // Debug: show mask
    if (u_showMask > 0.5) {
        float maskValue = texture(u_effectMask, v_uv).r;
        float textValue = texture(u_textTexture, v_uv).r;
        maskValue = max(maskValue, textValue);
        fragColor = vec4(vec3(maskValue), alpha);
        return;
    }

    // Overlay number (white text, no shader effects)
    float numberAlpha = texture(u_numberTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), numberAlpha);

    // Overlay collection name (white text, no shader effects)
    float collectionAlpha = texture(u_collectionTexture, v_uv).r;
    finalColor = mix(finalColor, vec3(1.0), collectionAlpha);

    // Alpha = mask for selective bloom (only effect regions bloom)
    fragColor = vec4(finalColor, 1.0);
}
`
    },
}

// Post-processing shaders
export const POST_SHADERS = {
    'fullscreen': {
        vertex: `#version 300 es

layout(location = 0) in vec2 a_position;
layout(location = 1) in vec2 a_uv;

out vec2 v_uv;

void main() {
    v_uv = a_uv;
    gl_Position = vec4(a_position, 0.0, 1.0);
}
`,
    },
    'bloomExtract': {
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;

uniform sampler2D u_texture;
uniform float u_threshold;

out vec4 fragColor;

void main() {
    vec4 color = texture(u_texture, v_uv);

    // Only extract HDR overflow (values > 1.0) - this is where effects add brightness
    // Regular texture stays in 0-1 range and won't bloom
    float maxChannel = max(max(color.r, color.g), color.b);
    float hdrOverflow = max(0.0, maxChannel - 1.0);

    if (hdrOverflow > 0.0) {
        // Extract the HDR portion that exceeds 1.0
        float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
        float contribution = hdrOverflow / (hdrOverflow + 0.3);
        fragColor = vec4(color.rgb * contribution, 1.0);
    } else {
        fragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
}
`,
    },
    'kawaseDown': {
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_halfPixel;  // 0.5 / resolution

out vec4 fragColor;

void main() {
    // Dual Kawase downsample: 5 samples leveraging hardware bilinear filtering
    // Samples the center + 4 corners offset by half-pixel
    // Hardware filtering effectively gives us 4x the samples for free

    vec4 sum = texture(u_texture, v_uv) * 4.0;
    sum += texture(u_texture, v_uv - u_halfPixel);
    sum += texture(u_texture, v_uv + u_halfPixel);
    sum += texture(u_texture, v_uv + vec2(u_halfPixel.x, -u_halfPixel.y));
    sum += texture(u_texture, v_uv + vec2(-u_halfPixel.x, u_halfPixel.y));

    fragColor = sum / 8.0;
}
`,
    },
    'kawaseUp': {
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;

uniform sampler2D u_texture;
uniform vec2 u_halfPixel;  // 0.5 / resolution

out vec4 fragColor;

void main() {
    // Dual Kawase upsample: 8 samples in tent filter pattern
    // Weighted sampling creates smooth interpolation during upscale

    vec4 sum = vec4(0.0);

    // Corner samples (weight 1)
    sum += texture(u_texture, v_uv + vec2(-u_halfPixel.x * 2.0, 0.0));
    sum += texture(u_texture, v_uv + vec2(0.0, u_halfPixel.y * 2.0));
    sum += texture(u_texture, v_uv + vec2(u_halfPixel.x * 2.0, 0.0));
    sum += texture(u_texture, v_uv + vec2(0.0, -u_halfPixel.y * 2.0));

    // Diagonal samples (weight 2)
    sum += texture(u_texture, v_uv + vec2(-u_halfPixel.x, u_halfPixel.y)) * 2.0;
    sum += texture(u_texture, v_uv + vec2(u_halfPixel.x, u_halfPixel.y)) * 2.0;
    sum += texture(u_texture, v_uv + vec2(u_halfPixel.x, -u_halfPixel.y)) * 2.0;
    sum += texture(u_texture, v_uv + vec2(-u_halfPixel.x, -u_halfPixel.y)) * 2.0;

    fragColor = sum / 12.0;
}
`,
    },
    'composite': {
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;

uniform sampler2D u_scene;
uniform sampler2D u_bloom;
uniform float u_bloomIntensity;

out vec4 fragColor;

void main() {
    vec4 scene = texture(u_scene, v_uv);
    vec3 bloomColor = texture(u_bloom, v_uv).rgb;

    // Additive bloom
    vec3 finalColor = scene.rgb + bloomColor * u_bloomIntensity;

    // Bloom contributes to alpha so glow extends beyond card edges
    // Card pixels: scene.a = 1.0 (opaque)
    // Background with bloom: scene.a = 0 but bloom makes it visible
    // Background without bloom: stays transparent
    float bloomBrightness = dot(bloomColor, vec3(0.299, 0.587, 0.114)) * u_bloomIntensity;
    float finalAlpha = max(scene.a, clamp(bloomBrightness, 0.0, 1.0));

    fragColor = vec4(finalColor, finalAlpha);
}
`,
    },
    'effects': {
        fragment: `#version 300 es
precision highp float;

in vec2 v_uv;

uniform sampler2D u_scene;

out vec4 fragColor;

void main() {
    // Simple passthrough - HDR/saturation removed
    fragColor = texture(u_scene, v_uv);
}
`,
    },
}

// Combined registry for easy access
export const SHADERS = {
    ...CARD_SHADERS,
    post: POST_SHADERS
}

// Helper to get shader pair with fallback to base vertex
export function getShaderPair(name) {
    const shader = CARD_SHADERS[name]
    if (!shader) {
        throw new Error(`Unknown shader: ${name}`)
    }
    return {
        vertex: shader.vertex ?? BASE_VERTEX,
        fragment: shader.fragment
    }
}

// List of available card shader names
export const SHADER_NAMES = Object.keys(CARD_SHADERS)
