#!/usr/bin/env node
/**
 * Build script to bundle all GLSL shaders into a single JavaScript module.
 * Resolves #include directives at build time.
 *
 * Usage: node scripts/build-shaders.js
 * Output: src/lib/ShaderRegistry.js
 */

import fs from 'fs/promises'
import path from 'path'
import { fileURLToPath } from 'url'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const ROOT_DIR = path.resolve(__dirname, '..')
const SHADERS_DIR = path.join(ROOT_DIR, 'src/shaders')
const INCLUDES_DIR = path.join(SHADERS_DIR, 'includes')
const OUTPUT_FILE = path.join(ROOT_DIR, 'src/lib/ShaderRegistry.js')

// Card effect shaders (each has fragment shader, shares base vertex)
const CARD_SHADERS = [
    'base',
    'holographic',
    'foil',
    'parallax',
    'cracked-ice',
    'refractor',
    'galaxy',
    'starburst',
    'prizm',
    'etched'
]

// Post-processing shaders
const POST_SHADERS = {
    fullscreen: { vertex: 'fullscreen.vert.glsl' },
    bloomExtract: { fragment: 'bloom-extract.frag.glsl' },
    kawaseDown: { fragment: 'kawase-down.frag.glsl' },
    kawaseUp: { fragment: 'kawase-up.frag.glsl' },
    composite: { fragment: 'composite.frag.glsl' },
    effects: { fragment: 'effects.frag.glsl' }
}

// Include file cache
const includeCache = new Map()

/**
 * Escape a string for use in a JavaScript template literal
 */
function escapeForTemplateLiteral(str) {
    return str
        .replace(/\\/g, '\\\\')     // Escape backslashes first
        .replace(/`/g, '\\`')       // Escape backticks
        .replace(/\$/g, '\\$')      // Escape dollar signs (template interpolation)
}

/**
 * Load an include file
 */
async function loadInclude(name) {
    if (includeCache.has(name)) {
        return includeCache.get(name)
    }

    const includePath = path.join(INCLUDES_DIR, name)
    try {
        const source = await fs.readFile(includePath, 'utf-8')
        includeCache.set(name, source)
        return source
    } catch (err) {
        console.warn(`Warning: Include file not found: ${name}`)
        return `// Include not found: ${name}`
    }
}

/**
 * Resolve #include directives in shader source
 */
async function resolveIncludes(source) {
    const includeRegex = /#include\s+["<]([^">]+)[">]/g
    const matches = [...source.matchAll(includeRegex)]

    for (const match of matches) {
        const includeName = match[1]
        const includeSource = await loadInclude(includeName)
        source = source.replace(match[0], includeSource)
    }

    return source
}

/**
 * Load and process a shader file
 */
async function loadShader(filePath) {
    try {
        let source = await fs.readFile(filePath, 'utf-8')
        source = await resolveIncludes(source)
        return escapeForTemplateLiteral(source)
    } catch (err) {
        console.error(`Error loading shader: ${filePath}`)
        throw err
    }
}

/**
 * Build the shader registry
 */
async function buildShaderRegistry() {
    console.log('Building shader registry...')

    const registry = {
        card: {},
        post: {}
    }

    // Load base vertex shader (shared by all card shaders)
    const baseVertexPath = path.join(SHADERS_DIR, 'base/base.vert.glsl')
    const baseVertex = await loadShader(baseVertexPath)

    // Load card shaders
    for (const shaderName of CARD_SHADERS) {
        const fragPath = path.join(SHADERS_DIR, `${shaderName}/${shaderName}.frag.glsl`)
        const fragment = await loadShader(fragPath)

        registry.card[shaderName] = {
            vertex: shaderName === 'base' ? baseVertex : null,
            fragment: fragment
        }

        console.log(`  ✓ ${shaderName}`)
    }

    // Load post-processing shaders
    for (const [name, files] of Object.entries(POST_SHADERS)) {
        const shaderEntry = {}

        if (files.vertex) {
            const vertPath = path.join(SHADERS_DIR, 'post', files.vertex)
            shaderEntry.vertex = await loadShader(vertPath)
        }

        if (files.fragment) {
            const fragPath = path.join(SHADERS_DIR, 'post', files.fragment)
            shaderEntry.fragment = await loadShader(fragPath)
        }

        registry.post[name] = shaderEntry
        console.log(`  ✓ post/${name}`)
    }

    return registry
}

/**
 * Generate the JavaScript module
 */
function generateModule(registry) {
    let output = `/**
 * Auto-generated shader registry
 * Generated by: scripts/build-shaders.js
 * Do not edit manually!
 */

// Base vertex shader (shared by all card effects)
export const BASE_VERTEX = \`${registry.card.base.vertex}\`

// Card effect shaders
export const CARD_SHADERS = {
`

    for (const [name, shader] of Object.entries(registry.card)) {
        const vertexRef = name === 'base' ? 'BASE_VERTEX' : 'null'
        output += `    '${name}': {
        vertex: ${vertexRef},
        fragment: \`${shader.fragment}\`
    },
`
    }

    output += `}

// Post-processing shaders
export const POST_SHADERS = {
`

    for (const [name, shader] of Object.entries(registry.post)) {
        output += `    '${name}': {\n`
        if (shader.vertex) {
            output += `        vertex: \`${shader.vertex}\`,\n`
        }
        if (shader.fragment) {
            output += `        fragment: \`${shader.fragment}\`,\n`
        }
        output += `    },\n`
    }

    output += `}

// Combined registry for easy access
export const SHADERS = {
    ...CARD_SHADERS,
    post: POST_SHADERS
}

// Helper to get shader pair with fallback to base vertex
export function getShaderPair(name) {
    const shader = CARD_SHADERS[name]
    if (!shader) {
        throw new Error(\`Unknown shader: \${name}\`)
    }
    return {
        vertex: shader.vertex ?? BASE_VERTEX,
        fragment: shader.fragment
    }
}

// List of available card shader names
export const SHADER_NAMES = Object.keys(CARD_SHADERS)
`

    return output
}

/**
 * Main build function
 */
async function main() {
    try {
        const registry = await buildShaderRegistry()
        const moduleSource = generateModule(registry)

        await fs.writeFile(OUTPUT_FILE, moduleSource, 'utf-8')

        console.log(`\n✓ Shader registry written to: ${path.relative(ROOT_DIR, OUTPUT_FILE)}`)
        console.log(`  Card shaders: ${CARD_SHADERS.length}`)
        console.log(`  Post shaders: ${Object.keys(POST_SHADERS).length}`)
    } catch (err) {
        console.error('Build failed:', err)
        process.exit(1)
    }
}

main()
